#include <ros/ros.h>
#include <nodelet/nodelet.h>
#include <sensor_msgs/Joy.h> 
#include <sensor_msgs/PointCloud2.h>
#include <pcl_ros/point_cloud.h> 
#include "gazebo_msgs/ModelStates.h"
#include "gazebo_msgs/ModelState.h"
#include <geometry_msgs/Twist.h>
#include <geometry_msgs/Point.h>
#include <geometry_msgs/Pose.h>
#include <math.h>
using namespace std;

class JoyControlClass{

public:
	ros::NodeHandle nh;
	ros::Subscriber joy_sub;
	ros::Subscriber position_sub;
	ros::Subscriber point_sub;
	ros::Publisher cmd_pub;
        ros::Timer publish_timer;
	sensor_msgs::Joy joy_msg;
        sensor_msgs::Joy recent_joy;
	geometry_msgs::Twist velocity;
        bool take_off_mode ;
        bool land_mode;
	bool first_joy_received;
	bool motors_on;
	bool took_off;
        bool need_filter;
	double v_x_max;
	double v_y_max;
	double v_z_max;
	double v_yaw_max;
	double recent_z;
	double deadband;
        double v_x;
        double v_y;
        double v_z;
        double v_yaw;
	//obstacle parameters
	double filtered_v_x;
	double filtered_v_y;
        double d_max;
        double time_commande;
        double time_point;  
  JoyControlClass()
  {
	  
	  position_sub = nh.subscribe("gazebo/model_states", 1, &JoyControlClass::positionCallback, this);
          joy_sub = nh.subscribe("joy", 1, &JoyControlClass::joyCallback, this);
          point_sub = nh.subscribe("lidar_points_dangerous", 1, &JoyControlClass::pointCallback, this);
	  cmd_pub =  nh.advertise<geometry_msgs::Twist> ("cmd_vel", 1);
          publish_timer = nh.createTimer(ros::Duration(1/20.0), &JoyControlClass::publishCmdCallBack, this);
	  first_joy_received = false;
          take_off_mode = false;
          land_mode = false;
	  took_off = false;
	  motors_on = false; 
          need_filter = false;
	  nh.param<double>("v_x_max", v_x_max, 2.0);
	  nh.param<double>("v_y_max", v_y_max, 2.0);
	  nh.param<double>("v_z_max", v_z_max, 2.0);
	  nh.param<double>("v_yaw_max", v_yaw_max, M_PI/2.0);
	  nh.param<double>("deadband", deadband, 0.005);
          nh.param<double>("d_max", d_max, 0.8);

  }

  void joyCallback(const sensor_msgs::JoyConstPtr& joy)
  {
          recent_joy = *joy;
	  //start the motors
	  if(not motors_on and joy->buttons[1]){
		  motors_on = true;
		  ROS_INFO("motors running");
	  }
	  if(motors_on){
		  
		  //take off with button 1
		  if(not took_off and joy->buttons[0]){
                     if(joy->axes[3] == 0){
                         take_off_mode = true;
                    }
                     else{
                         ROS_ERROR("The attitude commande is not put at 0. Please fix it."); 
                    }
                    }
                   //land 
                  if(took_off and joy->buttons[0]){
                      land_mode = true;                      
		  }
         
               }   
		  //during the flight
		  
  }


  void positionCallback(const gazebo_msgs::ModelStates::ConstPtr& sta){
	  gazebo_msgs::ModelStates state = *sta;
	  recent_z = state.pose[1].position.z;
         
  }
 
 void publishCmdCallBack(const ros::TimerEvent& e){
     double v_tx, v_ty, v_tz, v_tyaw;
     if(motors_on){
     if(take_off_mode and not took_off){
                        std::cout << "current height: " << (double)recent_z << std::endl; 
		  	if(recent_z < 0.45){
			  v_tx = 0.0;
			  v_ty = 0.0;
			  v_tz = 0.2;
			  v_tyaw = 0.0;
		 	 }
			else if(recent_z > 0.52){
                          v_tx = 0.0;
                          v_ty = 0.0;
                          v_tz = -0.2;
			  v_tyaw = 0.0;
                          /*velocity.linear.x = 0.0;
			  velocity.linear.y = 0.0;
			  velocity.linear.z = -0.2;
			  velocity.angular.z = 0.0; */
			}
		  	else{
			  v_tx = 0.0;
			  v_ty = 0.0;
			  v_tz = 0.0;
			  v_tyaw = 0.0;
                          take_off_mode = false; 
			  took_off = true;
                          ROS_INFO("manual mode");
			  }
     }
     if(took_off){
                        if(land_mode){
                           std::cout << "current height: " << (double)recent_z << std::endl; 
                           if(fabs(recent_z - 0.084705) > 0.0005){
                          	 v_tx = 0.0;
			 	 v_ty = 0.0;
			 	 v_tz = -0.2;
			 	 v_tyaw = 0.0;                           
                             }
                           else{
                              ROS_INFO("land finished");
                              v_tx = 0.0;
			      v_ty = 0.0;
			      v_tz = -0.03;
			      v_tyaw = 0.0; 
                              took_off = false;
                              motors_on = false;
                              land_mode = false;
                            }  
			}  
                        else{
                        
			       v_tx = recent_joy.axes[1];
		    	       v_ty = recent_joy.axes[0];
		  	       v_tz = recent_joy.axes[3];
		  	       v_tyaw = recent_joy.axes[2];

		 	 //determine the sign
		  	double x_sign = (v_tx > 0) ? 1.0 : -1.0;	
		  	double y_sign = (v_ty > 0) ? 1.0 : -1.0;
		  	double z_sign = (v_tz > 0) ? 1.0 : -1.0;
 		  	double yaw_sign = (v_tyaw > 0) ? 1.0 : -1.0;

		 	 v_tx= x_sign*v_tx > deadband ? (std::max(-1.0, min(1.0, v_tx)) - x_sign*deadband)/(1.0 - deadband)*v_x_max:0.0;
		 	 v_ty= y_sign*v_ty > deadband ? (std::max(-1.0, min(1.0, v_ty)) - y_sign*deadband)/(1.0 - deadband)*v_y_max:0.0;
		  	v_tz= z_sign*v_tz > deadband ? (std::max(-1.0, min(1.0, v_tz)) - z_sign*deadband)/(1.0 - deadband)*v_z_max:0.0;
		 	 v_tyaw= yaw_sign*v_tyaw > deadband ? (std::max(-1.0, min(1.0, v_tyaw)) - yaw_sign*deadband)/(1.0 - deadband)*v_yaw_max:0.0;
			 if(need_filter){
				 v_tx = filtered_v_x;
				 v_ty = filtered_v_y;
                                
			 } 
		    }
                 }		  		
	  }
     else{
        v_tx = 0.0;
	v_ty = 0.0;
	v_tz = 0.0;
	v_tyaw = 0.0;
     }
      std::cout << "vx: " << (double)v_tx << "vy: " << (double)v_ty <<std::endl; 
      v_x = v_tx;
      v_y = v_ty;
      v_z = v_tz;
      v_yaw = v_tyaw;
     velocity.linear.x = v_x;
     velocity.linear.y = v_y;
     velocity.linear.z = v_z;
     velocity.angular.z = v_yaw;
     cmd_pub.publish(velocity);

}

void pointCallback(const sensor_msgs::PointCloud2::ConstPtr& msg){
	pcl::PointCloud<pcl::PointXYZ> temp;
        pcl::fromROSMsg(*msg, temp);
        double min_dis = 10.0;
        unsigned int mark_of_min;
        unsigned int n_pcl = temp.size();
        for(unsigned int i = 0; i < n_pcl ; i++){
 		double x,y,z;
                x= temp[i].x;
                y= temp[i].y;
                z= temp[i].z;
                double dis = sqrt(x*x + y*y);
                if(dis < min_dis){
                  min_dis = dis;
                  mark_of_min = i;
                }        
        }
       need_filter = false;
        //std::cout << "min_dis: " << (double)min_dis << std::endl; 
       if( min_dis > 0.001 && min_dis < d_max && temp[mark_of_min].x*v_x+temp[mark_of_min].y*v_y > 0.05 ){
           need_filter = true;
           //ROS_INFO("filtering");
           
       }
       if(need_filter){
            
           	 double norm = sqrt(temp[mark_of_min].x*temp[mark_of_min].x + temp[mark_of_min].y*temp[mark_of_min].y);
            	filtered_v_x = - temp[mark_of_min].x/norm*(1.0*cos(M_PI*(min_dis-0.325)/(2*(d_max))));
           	 filtered_v_y = - temp[mark_of_min].y/norm*(1.0*cos(M_PI*(min_dis-0.325)/(2*(d_max))));
           
       } 



}


};



int main(int argc, char** argv){
	ros::init(argc, argv, "gazebo_joy_control");
	JoyControlClass controller = JoyControlClass();
        ROS_INFO("I m here");
	ros::Rate loop_rate(30);
	ros::spin();
	return 0;





}
